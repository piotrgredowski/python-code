---
title: How Rust is speeding up Python (bindings and tooling)
separator: <!--s-->
verticalSeparator: <!--v-->
revealOptions:
  transition: 'fade'
---

<style>
  img.small {
    width: 200px;

  }
  p.small {
    font-size: 0.5em;
  }
  blockquote {
    font-size: 0.7em;
    text-align: left;
  }

  a {
    font-size: 0.7em;
  }

</style>

## How Rust is speeding up Python (bindings and tooling)

"Rust and Python: A Match Made in Heaven\*" <!-- .element: class="fragment" data-fragment-index="1" -->

Piotr Grędowski, CoPy #5 @Ørsted, 06.03.2024

That's a subtitle generated by accident by Github Copilot. It's quite funny so I left it. <!-- .element: class="fragment small" data-fragment-index="2" -->

Note:
That's a subtitle generated by accident by Github Copilot. It's quite funny so I left it.

<!--s-->

<!-- .slide: data-background="images/rust_logo.png" -->
> **Rust** is a multi-paradigm, **general-purpose programming language** that emphasizes **performance**, **type safety**, and **concurrency**. It enforces **memory safety**—meaning that all references point to valid memory—without a garbage collector. To simultaneously enforce memory safety and prevent data races, its **"borrow checker"** tracks the object lifetime of all references in a program during compilation. Rust was influenced by ideas from **functional programming**, including **immutability**, higher-order functions, and algebraic data types. It is popular for systems programming. Rust was created by Graydon Hoare.

> https://en.wikipedia.org/wiki/Rust_(programming_language)


Note:
Rust is a general-purpose language emphasizing performance, type safety, and concurrency. It enforces memory safety without a garbage collector, using a "borrow checker" to prevent data races. Influenced by functional programming, it's popular for systems programming. Created by Graydon Hoare.
<!--s-->

![alt text](images/meme.png)

Note:
Rust and Python are both powerful programming languages, but they serve different purposes and have different strengths.

Rust
- statically typed,
- compiled language
- known for its performance and memory safety, especially safe concurrency.

Rust has a steep learning curve due to its unique concepts like ownership and borrowing.

Python
- dynamically typed,
- interpreted language
- known for its simplicity and readability.
It's a high-level language that's great for scripting and rapid application development.

If performance and memory safety are your top priorities, Rust would be a better choice. On the other hand, if you want to quickly develop applications or if you're working in fields like data analysis or machine learning, Python would be more suitable.

Today, we'll explore how Rust, a programming language known for its performance, safety and being super hard to learn, can significantly enhance Python development.

By leveraging Rust bindings to seamlessly integrate Rust libraries into Python applications, as well as utilizing Rust-built tools such as formatters and package managers, I'll demonstrate how this powerful combination can accelerate Python development while maintaining high performance and reliability. Let's delve into the exciting possibilities of marrying Rust's efficiency with Python's versatility for robust application development.

<!--s-->

# Bindings

<!-- .slide: data-background="images/pyo3.png" -->

<!--s-->

## What are bindings?

Rust bindings for Python are a bridge that allows developers to seamlessly integrate Rust code with Python programs. <!-- .element: class="fragment" data-fragment-index="1" -->

Note:
There's a library called `pyo3` that provides a way to write Python bindings in Rust.

Thanks to that we can write Python modules in Rust and use them in Python.

Of course there are already many tools and libraries that are written in Rust and can be used in Python.

<!--s-->

## Python libraries written in Rust, examples

- orjson, <!-- .element: class="fragment" data-fragment-index="1" -->
  "Fast, correct Python JSON library supporting dataclasses, datetimes, and numpy"
- polars, <!-- .element: class="fragment" data-fragment-index="2" -->
  "Dataframes powered by a multithreaded, vectorized query engine, written in Rust"
- pydantic-core, <!-- .element: class="fragment" data-fragment-index="3" -->
  "Core validation logic for pydantic written in Rust"

Note:
orjson is a high-performance Python library for JSON, offering native serialization for dataclass, datetime, numpy, and UUID instances, and outperforming the standard json library in speed and correctness.

Polars is a high-performance, multi-threaded Python library for dataframes, written in Rust for effective parallelism and cache-coherent algorithms. It's designed for intuitive, performant data wrangling

Pydantic is a fast, extensible data validation library for Python, leveraging type hints for schema validation and serialization. Its core validation logic is written in Rust, enhancing its performance.
<!--s-->

### Outsourcing performance-critical code from Python to Rust,

Article by Ohad Ravid

![Article by Ohad Ravid](<images/Screenshot 2024-02-28 at 19.25.44.png>)

<!--v-->

Starting point, Python implementation

```python
def find_close_polygons(
    polygon_subset: List[Polygon], point: np.array, max_dist: float
) -> List[Polygon]:
    close_polygons = []
    for poly in polygon_subset:
        if np.linalg.norm(poly.center - point) < max_dist:
            close_polygons.append(poly)

    return close_polygons
```

Iteration time

```bash
$ python measure.py
Took an avg of 293.41ms per iteration
```

<!--v-->

<style>
pre.code-wrapper {
  font-size: 0.4em;
  height: 70%;
}
</style>

After rewriting to Rust...

```rust
use pyo3::prelude::*;

use ndarray_linalg::Norm;
use numpy::PyReadonlyArray1;

#[pyfunction]
fn find_close_polygons(
    py: Python<'_>,
    polygons: Vec<PyObject>,
    point: PyReadonlyArray1<f64>,
    max_dist: f64,
) -> PyResult<Vec<PyObject>> {
    let mut close_polygons = vec![];
    let point = point.as_array();
    for poly in polygons {
        let center = poly
            .getattr(py, "center")?
            .extract::<PyReadonlyArray1<f64>>(py)?
            .as_array()
            .to_owned();

        if (center - point).norm() < max_dist {
            close_polygons.push(poly)
        }
    }

    Ok(close_polygons)
}
```

How much time will it take?

<style>
  div.slide-background-content {
    opacity: 0.5;
  }
</style>
```bash
$ (cd ./poly_match_rs/ && maturin develop)
$ python measure.py
Took an avg of ??????s per iteration
```

<!--v-->

Starting point, Python code

```bash
$ python measure.py
Took an avg of 293.41ms per iteration
```

After rewriting to Rust

<!-- .slide: data-background="images/what.png" data-background-transition="zoom"-->

```bash
$ (cd ./poly_match_rs/ && maturin develop)
$ python measure.py
Took an avg of 609.46ms per iteration
```
<!-- style a div to make all elements centered vertically -->
<div style="display: flex; align-items: center; justify-content: center;">
  <img class="small" src="images/what2.png" />
  <p><b style="color: red">609.46ms</b> per iteration!</p>
  <img class="small" src="images/what3.png" />
</div>

<!--v-->

After rewriting to Rust and buiding with release flag

```bash
$ (cd ./poly_match_rs/ && maturin develop --release)
$ python measure.py
Took an avg of 23.44ms per iteration
```

After all improvements

```bash
$ python measure.py
Took an avg of 2.90ms per iteration
```
<!--v-->

Starting with Python implementation

```python
@dataclass
class Polygon:
    x: np.array
    y: np.array
    _area: float = None

    @cached_property
    def center(self) -> np.array:
        centroid = np.array([self.x, self.y]).mean(axis=1)
        return centroid

    def area(self) -> float:
        ...

def find_close_polygons(
    polygon_subset: List[Polygon], point: np.array, max_dist: float
) -> List[Polygon]:
    close_polygons = []
    for poly in polygon_subset:
        if np.linalg.norm(poly.center - point) < max_dist:
            close_polygons.append(poly)

    return close_polygons
```

```python
import poly_match_rs

poly_match_rs.Polygon
poly_match_rs.find_close_polygons

...
```

Note:
You can also write your own Rust library and use it in Python.

I'll give you a link to a great article about how Rust solved a performance problem in a 3D processing pipeline.

The article discusses enhancing Python performance by integrating Rust, focusing on optimizing application's core Python library used in a 3D processing pipeline.
Facing scalability issues with increased workload, the team sought to make the system significantly faster, turning to Rust for its performance benefits.
By iteratively optimizing specific functions like finding close polygons, significant performance gains of up to 100x were achieved through careful Rust integration, while retaining the original Python API and ensuring minimal compromises.
The process involved profiling, rewriting critical functions in Rust, and addressing memory allocation overhead, showcasing the powerful combination of Rust's native performance and Python's ease of use for researchers.


<!--s-->

# Tooling

<!--s-->

- **ruff**, A Rust formatter that is compatible with black and almost all others Python linters

  https://github.com/astral-sh/ruff

![alt text](images/ruff.png)

<!--v-->

- **uv**, a very fast (but still young) alternative to pip for installing packages

  https://github.com/astral-sh/uv

![alt text](images/uv.png)

<!--v-->

- **rye**, awesome package manager for Python, inspired by Rust's cargo, created by Armin Ronacher

  https://github.com/astral-sh/rye

![alt text](images/rye.png)

<!--s-->
## Thank you!
Links:  <!-- .element: class="fragment" data-fragment-index="1" -->

[https://ohadravid.github.io/posts/2023-03-rusty-python/](https://ohadravid.github.io/posts/2023-03-rusty-python/) <!-- .element: class="fragment" data-fragment-index="1" -->

[pyo3,](https://github.com/PyO3/pyo3) <!-- .element: class="fragment" data-fragment-index="1" -->
[orjson,](https://github.com/ijl/orjson) <!-- .element: class="fragment" data-fragment-index="1" -->
[polars,](https://github.com/pola-rs/polars) <!-- .element: class="fragment" data-fragment-index="1" -->
[pydantic-core](https://github.com/pydantic/pydantic-core) <!-- .element: class="fragment" data-fragment-index="1" -->

[ruff,](https://github.com/astral-sh/ruff) <!-- .element: class="fragment" data-fragment-index="1" -->
[uv,](https://github.com/astral-sh/uv) <!-- .element: class="fragment" data-fragment-index="1" -->
[rye](https://github.com/astral-sh/rye) <!-- .element: class="fragment" data-fragment-index="1" -->

[An Introduction to Coding In Rust for Pythonistas by ArjanCodes](https://www.youtube.com/watch?v=MoqtsYLGCC4) <!-- .element: class="fragment" data-fragment-index="1" -->

[Combining Rust and Python: The Best of Both Worlds? by ArjanCodes](https://www.youtube.com/watch?v=lyG6AKzu4ew) <!-- .element: class="fragment" data-fragment-index="1" -->

[how-to-use-rust-with-python-and-python-with-rust](https://www.infoworld.com/article/3664124/how-to-use-rust-with-python-and-python-with-rust.html) <!-- .element: class="fragment" data-fragment-index="1" -->

[astral.sh](https://astral.sh/) <!-- .element: class="fragment" data-fragment-index="1" -->
